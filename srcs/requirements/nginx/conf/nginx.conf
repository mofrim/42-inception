# a good ressource for generating a basic nginx conf with modern and secure
# basic settings is: https://ssl-config.mozilla.org/

worker_processes auto;

user nginx;

events {
	worker_connections 1024;
}

http {
  # without including mime.types nginx would not know how to correctly serve
  # .jpg or .js, or, even more importantly, css-files! For example if a user
  # requests `../bla.jpg` nginx with these settings knows the header to serve:
  # `Content-Type: image/jpg`. Without it doesn't and, for example, stylesheets
  # are not parsed correctly.
	include       /etc/nginx/mime.types;
  # this is the fallback mime-type for unknown ft's
	default_type  application/octet-stream;

  # enables sendfile syscall to directly serve static content from disk. mainly
  # performance reasons
	sendfile        on;

  # keepalive connections allow the re-use of on TCP connection which reduces
  # latency
	keepalive_timeout  65;

	server {
		listen 443 ssl;
    listen [::]:443 ssl; # also activate ssl for ipv6-only clients

    # we are only serving using TLS so we can activate HTTP/2 which is more
    # performant than HTTP/1.1. this backward compatible.
    http2 on;

		server_name fmaurer.42.fr;

		ssl_certificate     /etc/nginx/ssl/server-cert.pem;
		ssl_certificate_key /etc/nginx/ssl/server-key.pem;

		ssl_protocols TLSv1.2 TLSv1.3;

    # this setting determines which elliptic curves the server will use for
    # Elliptic Curve Diffie-Hellman Ephemeral (ECDHE) key exchange during the
    # SSL/TLS handshake. first one has highest prio and is the most modern one.
    # if this was not set, nginx would pick default curves. this is only to make
    # it explicit.
    ssl_ecdh_curve X25519:prime256v1:secp384r1;
		ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';

    # being strict here. if your client does not support any of our secure
    # ciphers there is no connection!
		ssl_prefer_server_ciphers on;

    # cache ssl handshakes so do not have to be repeated if a client visits the
    # server more often in a short period of time
		ssl_session_cache shared:SSL:10m;
		ssl_session_timeout 10m;

    # Root for WordPress
    root /var/www/html/wp;
    index index.php index.html index.htm;

		# when putting a slash to the end of a location this will only match
		# requests ending with exactly "../hello-world/" not "../hello-world"!
		# location /hello-world/ {

		# without trailing slash matches both with or without trailing slash
		# requests.
		location /test {
			# if would i have defined:
			#
			# 		location /hello-world {
			# 		    root   /usr/share/nginx/html;
			# 		    index  index.html index.htm;
			# 		}
			#
			# a request to "localhost/hello-world" would look for files in
			# /usr/share/nginx/html/hello-world.
			alias   /var/www/html;
			try_files $uri $uri/ index.html;
			# index  index.html index.htm;
		}

		# better do not use alias here bc php-fpm might not find the correct files
		# then. use `root` instead. fixed the last `403 Forbidden`
		location / {
			# alias /var/www/html/wp;
			# index index.php;
			try_files $uri $uri/ /index.php?$args;
		}

		location ~ \.php$ {
			fastcgi_pass wp:9000;
			fastcgi_index index.php;
			fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
			# Include all standard FastCGI params
			include fastcgi_params;
			fastcgi_param PHP_VALUE "error_log=/var/log/nginx/php-fpm.log";
		}

   # Deny access to hidden files
    location ~ /\.(?!well-known) {
        deny all;
    }
	}
}
